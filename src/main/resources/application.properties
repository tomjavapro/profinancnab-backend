spring.application.name=profinancnab

# ------------------------------------------------------------------------------

# Inicializar o schema do Spring Batch. Dos metadados.
spring.batch.jdbc.initialize-schema=always

# Para executar o schema.sql e criar a tabela no H2.
# Removendo para fazer o deploy no Web Service.
spring.sql.init.mode=always
# # Alterando no deploy
# Voltando para always, para testar.
# spring.sql.init.mode=never

# ------------------------------------------------------------------------------

# spring.datasource.url=jdbc:h2:mem:testdb

# Criar o diretório 'data' na raiz do projeto. Mantem os arquivos do banco.
# spring.datasource.url=jdbc:h2:file:./data/db
# A URL será subistituída no docker-compose.

# postgresql
# CORRIGIDO: usar porta 5432 (container) não 5436 (host)
# Removendo no deploy
# spring.datasource.url=jdbc:postgresql://postgres-db:5432/profinancnab_db

# Removendo para usar o postgres
# spring.datasource.driverClassName=org.h2.Driver

# Opcional. O Spring 2.x/3.x já detecta o postgres pelo 'spring.datasource.url'
# Se configurado no 'build.gradle' então já está na path
# Removendo no deploy
# spring.datasource.driver-class-name=org.postgresql.Driver

# spring.datasource.username=sa
# spring.datasource.password=

# postgres
# Removendo no deploy
# spring.datasource.username=user
# spring.datasource.password=kC4rYMBPY0

# Habilitando a visualização via console.
# Removendo para usar o postgres
# spring.h2.console.enabled=true


# ------------------------------------------------------------------------------
# A Solução está em customizar 'bootRun' em 'build.gradle'.
# Para revolver o problema da existência dos arquivos do banco.

    # ERRO (O erro ocorre porque há uma incompatibilidade entre as opções AUTO_SERVER=TRUE e DB_CLOSE_ON_EXIT=FALSE)
    # Opção 1
    # Para limpar o banco ao iniciar a aplicação
    # spring.datasource.url=jdbc:h2:file:./data/db;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE;AUTO_SERVER=TRUE

    # Parece que esta opção não está apagando.
    # Opção 2
    # Para deletar automaticamente o banco quando a aplicação parar
    # Para recriar o banco sempre que iniciar
    # spring.datasource.url=jdbc:h2:file:./data/db;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=TRUE

    # Opção 3
    # Para modo em memória (não gera arquivos)
    # spring.datasource.url=jdbc:h2:mem:testdb


    # ------------------------------------------------------------------------------
    # Opção 1: Configuração básica e estável
    # spring.datasource.url=jdbc:h2:file:./data/db;DB_CLOSE_DELAY=-1

    # Usar essa para acessar o console h2 no navegador.
    # Opção 2: Para múltiplas conexões (sem AUTO_SERVER)
    # spring.datasource.url=jdbc:h2:file:./data/db;DB_CLOSE_DELAY=-1;AUTO_SERVER=TRUE
        # Ainda não é esse!
        # Além de não remover os arquivos, criou um novo 'db.lock.db'.

    # Opção 3: Com fechamento automático
    # spring.datasource.url=jdbc:h2:file:./data/db;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=TRUE

    # ------------------------------------------------------------------------------
    # Solução
    # Usar a task no build.gradle.
    # <> ./gradlew cleanH2Database; ./gradlew bootRun



# ------------------------------------------------------------------------------
# Configuração que conterá o caminho do diretório temporário.
file.upload-dir=temp

# // Precisamos desabilitar a execução padrão do Bean Job, no arquivo properties.
spring.batch.job.enabled=false



# ------------------------------------------------------------------------------
logging.level.root=DEBUG
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

# # Debug detalhado
# logging.level.org.springframework.jdbc=DEBUG
# logging.level.org.springframework.boot.autoconfigure.jdbc=DEBUG
# logging.level.org.postgresql=DEBUG

# # Mostrar SQL executado
# spring.jpa.show-sql=true
# spring.jpa.properties.hibernate.format_sql=true